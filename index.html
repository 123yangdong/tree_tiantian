
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grand Luxury Christmas Tree</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Monsieur+La+Doulaise&display=swap" rel="stylesheet">
    <!-- Babel for in-browser JSX/TS compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
      body { margin: 0; background-color: #010a05; overflow: hidden; }
      .font-luxury { font-family: 'Cinzel', serif; }
      .font-body { font-family: 'Playfair Display', serif; }
      .font-script { font-family: 'Monsieur La Doulaise', cursive; }
      
      /* Animation Utilities */
      @keyframes scan {
          0% { transform: translateY(-100%); }
          100% { transform: translateY(100%); }
      }
      .animate-scan {
          animation: scan 3s linear infinite;
      }
      @keyframes spin-reverse {
          from { transform: rotate(360deg); }
          to { transform: rotate(0deg); }
      }
      .animate-spin-reverse {
          animation: spin-reverse 2s linear infinite;
      }
    </style>

    <!-- Import Map for Modules -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/": "https://esm.sh/react@18.2.0/",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?external=react",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
    "@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs@4.17.0",
    "@tensorflow-models/handpose": "https://esm.sh/@tensorflow-models/handpose@0.1.0?external=@tensorflow/tfjs",
    "react-webcam": "https://esm.sh/react-webcam@7.2.0?external=react,react-dom",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>

    <!-- MAIN APPLICATION SCRIPT -->
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useRef, useEffect, useMemo, useLayoutEffect } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';
      import { Canvas, useFrame, useThree, useLoader } from '@react-three/fiber';
      import { Environment, Stars } from '@react-three/drei';
      import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';
      import * as tf from '@tensorflow/tfjs';
      import * as handpose from '@tensorflow-models/handpose';
      import Webcam from 'react-webcam';

      // --- 1. UTILS (math.ts) ---
      
      const randomVector3 = (r) => {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      };

      const getConePosition = (height, radius, progress) => {
        const y = (progress - 0.5) * height; // -height/2 to height/2
        const r = (1 - progress) * radius; // Taper to top
        const angle = Math.random() * Math.PI * 2;
        const x = r * Math.cos(angle);
        const z = r * Math.sin(angle);
        return new THREE.Vector3(x, y, z);
      };

      const generateFoliageData = (count, treeHeight, treeRadius) => {
        const target = new Float32Array(count * 3);
        const chaos = new Float32Array(count * 3);
        const randoms = new Float32Array(count); 

        for (let i = 0; i < count; i++) {
          const progress = 1 - Math.sqrt(Math.random()); 
          
          const posT = getConePosition(treeHeight, treeRadius, progress);
          
          posT.x += (Math.random() - 0.5) * 1.0;
          posT.z += (Math.random() - 0.5) * 1.0;
          posT.y += (Math.random() - 0.5) * 1.0;

          target[i * 3] = posT.x;
          target[i * 3 + 1] = posT.y;
          target[i * 3 + 2] = posT.z;

          const posC = randomVector3(treeHeight * 1.5);
          chaos[i * 3] = posC.x;
          chaos[i * 3 + 1] = posC.y;
          chaos[i * 3 + 2] = posC.z;
          
          randoms[i] = Math.random();
        }

        return { target, chaos, randoms };
      };

      const generateSpiralData = (count, height, radius, turns) => {
        const target = new Float32Array(count * 3);
        const chaos = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
          const t = i / count; 
          const y = (t - 0.5) * height;
          const r = (1 - t) * radius + 0.5; 
          const angle = t * Math.PI * 2 * turns;

          target[i * 3] = r * Math.cos(angle);
          target[i * 3 + 1] = y;
          target[i * 3 + 2] = r * Math.sin(angle);

          const posC = randomVector3(height * 1.2);
          chaos[i * 3] = posC.x;
          chaos[i * 3 + 1] = posC.y;
          chaos[i * 3 + 2] = posC.z;
        }
        return { target, chaos };
      };

      const lerp = (start, end, t) => {
        return start * (1 - t) + end * t;
      };

      // --- 2. COMPONENTS ---

      // --- Foliage.tsx ---
      const Foliage = ({ mixFactor, colors }) => {
        // PERFORMANCE: Reduced particle count from 75000 to 35000 for smoother FPS
        const count = 35000; 
        const materialRef = useRef(null);
        const currentMixRef = useRef(1);
        const { target, chaos, randoms } = useMemo(() => generateFoliageData(count, 18, 7.5), [count]);

        const uniforms = useMemo(() => ({
          uTime: { value: 0 },
          uMix: { value: 1 },
          uSize: { value: 4.5 }, // Slightly increased size to compensate for lower count
          uColorBottom: { value: new THREE.Color(colors.bottom) },
          uColorTop: { value: new THREE.Color(colors.top) }
        }), []);

        useFrame((state, delta) => {
          if (materialRef.current) {
            const speed = 2.0 * delta; 
            currentMixRef.current = lerp(currentMixRef.current, mixFactor, speed);
            materialRef.current.uniforms.uTime.value = state.clock.elapsedTime;
            materialRef.current.uniforms.uMix.value = currentMixRef.current;
            materialRef.current.uniforms.uColorBottom.value.set(colors.bottom);
            materialRef.current.uniforms.uColorTop.value.set(colors.top);
          }
        });

        const vertexShader = `
          precision highp float;
          uniform float uTime;
          uniform float uMix;
          uniform float uSize;
          attribute vec3 aTargetPos;
          attribute vec3 aChaosPos;
          attribute float aRandom;
          varying vec3 vPos;
          varying float vRandom;
          varying float vIsSnow;
          void main() {
            vRandom = aRandom;
            vIsSnow = step(0.85, aRandom);
            vec3 pos = mix(aChaosPos, aTargetPos, uMix);
            float breath = sin(uTime + pos.y * 0.5) * 0.05 * uMix;
            pos.x += pos.x * breath;
            pos.z += pos.z * breath;
            vPos = pos;
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            gl_PointSize = uSize * (20.0 / -mvPosition.z) * (0.6 + 0.8 * aRandom);
          }
        `;

        const fragmentShader = `
          precision highp float;
          uniform vec3 uColorBottom;
          uniform vec3 uColorTop;
          varying vec3 vPos;
          varying float vRandom;
          varying float vIsSnow;
          void main() {
            float h = (vPos.y + 9.0) / 18.0;
            h = clamp(h, 0.0, 1.0);
            vec3 color = mix(uColorBottom, uColorTop, h);
            color *= 0.6 + 0.6 * vRandom;
            vec3 snowColor = vec3(0.95, 0.98, 1.0);
            color = mix(color, snowColor, vIsSnow * 0.9);
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
            gl_FragColor = vec4(color, alpha);
          }
        `;

        return (
          <points>
            <bufferGeometry>
              <bufferAttribute attach="attributes-position" count={count} array={target} itemSize={3} />
              <bufferAttribute attach="attributes-aTargetPos" count={count} array={target} itemSize={3} />
              <bufferAttribute attach="attributes-aChaosPos" count={count} array={chaos} itemSize={3} />
              <bufferAttribute attach="attributes-aRandom" count={count} array={randoms} itemSize={1} />
            </bufferGeometry>
            <shaderMaterial
              ref={materialRef}
              vertexShader={vertexShader}
              fragmentShader={fragmentShader}
              uniforms={uniforms}
              transparent
              depthWrite={false}
            />
          </points>
        );
      };

      // --- Snow.tsx ---
      const Snow = ({ mixFactor }) => {
        // PERFORMANCE: Reduced snow count from 3000 to 1500
        const count = 1500;
        const pointsRef = useRef(null);
        const materialRef = useRef(null);
        const currentMixRef = useRef(1);
        const { camera } = useThree();

        const { positions, scales, velocities } = useMemo(() => {
          const pos = new Float32Array(count * 3);
          const sc = new Float32Array(count);
          const vel = new Float32Array(count * 3);
          for(let i=0; i<count; i++) {
              pos[i*3] = (Math.random() - 0.5) * 50;
              pos[i*3+1] = (Math.random() - 0.5) * 30;
              pos[i*3+2] = (Math.random() - 0.5) * 40;
              sc[i] = Math.random() * 2 + 1;
              vel[i*3] = Math.random() * 0.5 + 0.2;
              vel[i*3+1] = Math.random() * 2.0 + 1.0;
              vel[i*3+2] = Math.random() * 0.5 + 0.2;
          }
          return { positions: pos, scales: sc, velocities: vel };
        }, [count]);

        const uniforms = useMemo(() => ({ uTime: { value: 0 }, uMix: { value: 1 } }), []);

        useFrame((state, delta) => {
           if (materialRef.current && pointsRef.current) {
               currentMixRef.current = lerp(currentMixRef.current, mixFactor, delta * 2.0);
               materialRef.current.uniforms.uTime.value = state.clock.elapsedTime;
               materialRef.current.uniforms.uMix.value = currentMixRef.current;
               pointsRef.current.position.x = camera.position.x;
               pointsRef.current.position.y = camera.position.y;
           }
        });

        const vertexShader = `
          precision highp float;
          uniform float uTime;
          uniform float uMix;
          attribute float aScale;
          attribute vec3 aVelocity;
          varying float vAlpha;
          void main() {
            vec3 pos = position;
            float fallSpeed = aVelocity.y; 
            pos.y = mod(pos.y - uTime * fallSpeed + 15.0, 30.0) - 15.0; 
            float drift = sin(uTime * aVelocity.x + pos.y) * (0.5 + (1.0 - uMix) * 2.0);
            pos.x += drift;
            pos.z += cos(uTime * aVelocity.z + pos.x) * 0.5;
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            gl_PointSize = aScale * (15.0 / -mvPosition.z);
            vAlpha = 1.0 - smoothstep(12.0, 15.0, abs(pos.y));
          }
        `;

        const fragmentShader = `
          precision highp float;
          varying float vAlpha;
          void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            if (dist > 0.5) discard;
            float alpha = (1.0 - smoothstep(0.3, 0.5, dist)) * vAlpha * 0.8;
            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
          }
        `;

        return (
          <points ref={pointsRef} frustumCulled={false}>
            <bufferGeometry>
              <bufferAttribute attach="attributes-position" count={count} array={positions} itemSize={3} />
              <bufferAttribute attach="attributes-aScale" count={count} array={scales} itemSize={1} />
              <bufferAttribute attach="attributes-aVelocity" count={count} array={velocities} itemSize={3} />
            </bufferGeometry>
            <shaderMaterial 
              ref={materialRef}
              vertexShader={vertexShader}
              fragmentShader={fragmentShader}
              uniforms={uniforms}
              transparent
              depthWrite={false}
            />
          </points>
        );
      };

      // --- SpiralLights.tsx ---
      const SpiralLights = ({ mixFactor }) => {
        const count = 300;
        const meshRef = useRef(null);
        const dummy = useMemo(() => new THREE.Object3D(), []);
        const currentMixRef = useRef(1);
        const { target, chaos } = useMemo(() => generateSpiralData(count, 19, 7.5, 9), []);

        useLayoutEffect(() => {
           if (!meshRef.current) return;
           const color = new THREE.Color("#fffae0");
           for(let i=0; i<count; i++) {
               meshRef.current.setColorAt(i, color);
               dummy.position.set(target[i*3], target[i*3+1], target[i*3+2]);
               dummy.scale.setScalar(0.15);
               dummy.updateMatrix();
               meshRef.current.setMatrixAt(i, dummy.matrix);
           }
           if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
           meshRef.current.instanceMatrix.needsUpdate = true;
        }, [target, dummy]);

        useFrame((state, delta) => {
          if (!meshRef.current) return;
          const speed = 2.0 * delta;
          currentMixRef.current = lerp(currentMixRef.current, mixFactor, speed);
          const t = currentMixRef.current;
          const time = state.clock.elapsedTime;
          
          for(let i=0; i<count; i++) {
            const x = lerp(chaos[i*3], target[i*3], t);
            const y = lerp(chaos[i*3+1], target[i*3+1], t);
            const z = lerp(chaos[i*3+2], target[i*3+2], t);
            dummy.position.set(x, y, z);
            const pulse = Math.sin(time * 3 + i * 0.1) * 0.05 + 0.15;
            dummy.scale.setScalar(pulse);
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
          }
          meshRef.current.instanceMatrix.needsUpdate = true;
        });

        return (
          <instancedMesh ref={meshRef} args={[undefined, undefined, count]}>
            <sphereGeometry args={[1, 8, 8]} />
            <meshBasicMaterial color="#fffae0" toneMapped={false} />
          </instancedMesh>
        );
      };

      // --- TopStar.tsx ---
      const createStarShape = (outerRadius, innerRadius, points) => {
          const shape = new THREE.Shape();
          const step = (Math.PI * 2) / (points * 2);
          shape.moveTo(0, outerRadius);
          for(let i = 0; i < points * 2; i++) {
              const radius = (i % 2 === 0) ? outerRadius : innerRadius;
              const angle = i * step;
              const effectiveAngle = angle + Math.PI / 2;
              shape.lineTo(Math.cos(effectiveAngle) * radius, Math.sin(effectiveAngle) * radius);
          }
          shape.closePath();
          return shape;
      };

      const TopStar = ({ mixFactor }) => {
        const groupRef = useRef(null);
        const visualRef = useRef(null);
        const starMeshRef = useRef(null);
        const currentMixRef = useRef(1);
        
        const geometry = useMemo(() => {
            const shape = createStarShape(1.2, 0.6, 5);
            const geom = new THREE.ExtrudeGeometry(shape, {
                depth: 0.4, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 4
            });
            geom.center();
            return geom;
        }, []);

        useFrame((state, delta) => {
            if (!groupRef.current || !visualRef.current || !starMeshRef.current) return;
            const speed = 2.0 * delta;
            currentMixRef.current = lerp(currentMixRef.current, mixFactor, speed);
            const t = currentMixRef.current;
            const targetY = 9.2;
            const chaosY = 13.0;
            const currentY = lerp(chaosY, targetY, t);
            groupRef.current.position.set(0, currentY, 0);
            starMeshRef.current.rotation.y += delta * 0.5;
            if (t < 0.9) {
                const chaosTilt = (1 - t) * 0.5;
                groupRef.current.rotation.z = Math.sin(state.clock.elapsedTime) * chaosTilt;
                groupRef.current.rotation.x = Math.cos(state.clock.elapsedTime * 0.8) * chaosTilt;
            } else {
                groupRef.current.rotation.z = lerp(groupRef.current.rotation.z, 0, speed);
                groupRef.current.rotation.x = lerp(groupRef.current.rotation.x, 0, speed);
            }
            visualRef.current.scale.setScalar(1.0);
        });

        return (
          <group ref={groupRef}>
              <group ref={visualRef}>
                  <mesh ref={starMeshRef} geometry={geometry}>
                      <meshStandardMaterial 
                          color="#FFD700" emissive="#FFD700" emissiveIntensity={2.0} roughness={0.1} metalness={0.9} toneMapped={false} 
                      />
                  </mesh>
              </group>
              <pointLight color="#ffeebf" intensity={3.0} distance={15} decay={2} />
          </group>
        );
      };

      // --- Ornaments.tsx Helpers ---
      const createCandyCaneGeometry = () => {
          const path = new THREE.CatmullRomCurve3([
              new THREE.Vector3(0, -1.0, 0), new THREE.Vector3(0, 0.5, 0),
              new THREE.Vector3(0.1, 0.8, 0), new THREE.Vector3(0.4, 0.9, 0),
              new THREE.Vector3(0.6, 0.6, 0) 
          ]);
          const geometry = new THREE.TubeGeometry(path, 32, 0.12, 8, false);
          geometry.center(); 
          return geometry;
      };

      const createOrnStarGeometry = (points, outerRadius, innerRadius, depth) => {
          const shape = new THREE.Shape();
          const step = (Math.PI * 2) / (points * 2);
          shape.moveTo(0, outerRadius);
          for(let i = 0; i < points * 2; i++) {
              const radius = (i % 2 === 0) ? outerRadius : innerRadius;
              const angle = i * step;
              shape.lineTo(Math.sin(angle) * radius, Math.cos(angle) * radius);
          }
          shape.closePath();
          const geometry = new THREE.ExtrudeGeometry(shape, {
              depth: depth, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelSegments: 2
          });
          geometry.center();
          return geometry;
      };

      const generateCandyStripeTexture = () => {
          const canvas = document.createElement('canvas');
          canvas.width = 128; canvas.height = 128;
          const ctx = canvas.getContext('2d');
          if (!ctx) return null;
          ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, 128, 128);
          ctx.fillStyle = '#cc0000'; 
          for (let i = -128; i < 256; i += 42) {
              ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i + 20, 0);
              ctx.lineTo(i + 20 + 128, 128); ctx.lineTo(i + 128, 128);
              ctx.closePath(); ctx.fill();
          }
          const tex = new THREE.CanvasTexture(canvas);
          tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
          tex.repeat.set(4, 1); 
          return tex;
      }

      const generateSignatureTexture = (text) => {
          const canvas = document.createElement('canvas');
          canvas.width = 512; canvas.height = 128;
          const ctx = canvas.getContext('2d');
          if (!ctx) return null;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          if (!text) return new THREE.CanvasTexture(canvas);
          ctx.fillStyle = '#111111'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.font = "bold 60px 'Monsieur La Doulaise', cursive";
          ctx.fillText(text, canvas.width / 2, canvas.height / 2);
          const tex = new THREE.CanvasTexture(canvas);
          tex.needsUpdate = true;
          return tex;
      }

      const PhotoFrameMesh = ({ item, mixFactor, texture, signatureTexture }) => {
          const groupRef = useRef(null);
          const innerRef = useRef(null); 
          const photoMatRef = useRef(null);
          const currentMixRef = useRef(1);
          const vecPos = useMemo(() => new THREE.Vector3(), []);
          const vecScale = useMemo(() => new THREE.Vector3(), []);
          const vecWorld = useMemo(() => new THREE.Vector3(), []);

          const { frameArgs, photoArgs, photoPos, textPos, textArgs } = useMemo(() => {
              const img = texture.image;
              const width = img?.width || 1;
              const height = img?.height || 1;
              const aspect = width / height;
              const maxSize = 0.85;
              let pw, ph;
              if (aspect >= 1) { pw = maxSize; ph = maxSize / aspect; } 
              else { ph = maxSize; pw = maxSize * aspect; }
              const mSide = 0.08; const mTop = 0.08; const mBottom = 0.20;
              const fw = pw + mSide * 2; const fh = ph + mTop + mBottom;
              const py = (fh / 2) - mTop - (ph / 2);
              const ty = -(fh / 2) + (mBottom / 2);
              return {
                  frameArgs: [fw, fh, 0.05], photoArgs: [pw, ph],
                  photoPos: [0, py, 0.03], textPos: [0, ty, 0.03], textArgs: [fw, mBottom]
              };
          }, [texture]);

          useFrame((state, delta) => {
              if (!groupRef.current || !innerRef.current) return;
              const speed = 2.0 * delta;
              currentMixRef.current = lerp(currentMixRef.current, mixFactor, speed);
              const t = currentMixRef.current;
              vecPos.lerpVectors(item.chaosPos, item.targetPos, t);
              groupRef.current.position.copy(vecPos);
              vecScale.lerpVectors(item.chaosScale, item.targetScale, t);
              const { width } = state.viewport;
              const isSmallScreen = width < 22; 
              const responsiveBaseScale = isSmallScreen ? 0.6 : 1.0;
              vecScale.multiplyScalar(responsiveBaseScale);
              const effectStrength = (1.0 - t);
              if (t < 0.99) {
                   groupRef.current.getWorldPosition(vecWorld);
                   const distToCamera = vecWorld.distanceTo(state.camera.position);
                   const maxZoom = isSmallScreen ? 1.1 : 1.5; 
                   const minZoom = 0.6;
                   const perspectiveFactor = THREE.MathUtils.mapLinear(distToCamera, 10, 60, maxZoom, minZoom);
                   const dynamicScale = lerp(1.0, perspectiveFactor, effectStrength);
                   vecScale.multiplyScalar(dynamicScale);
                   if (photoMatRef.current) {
                       const brightness = THREE.MathUtils.mapLinear(distToCamera, 12, 50, 0.9, 0.2);
                       photoMatRef.current.emissiveIntensity = Math.max(0.2, brightness) * effectStrength;
                   }
              } else {
                   if (photoMatRef.current) photoMatRef.current.emissiveIntensity = 0.25;
              }
              groupRef.current.scale.copy(vecScale);
              if (t > 0.8) {
                   groupRef.current.lookAt(0, groupRef.current.position.y, 0); 
                   groupRef.current.rotateY(Math.PI); 
                   innerRef.current.rotation.z = lerp(innerRef.current.rotation.z, 0, speed);
              } else {
                   groupRef.current.lookAt(state.camera.position);
                   innerRef.current.rotation.z = lerp(innerRef.current.rotation.z, item.chaosTilt, speed);
              }
          });

          return (
              <group ref={groupRef}>
                  <group ref={innerRef}>
                      <mesh>
                          <boxGeometry args={frameArgs} />
                          <meshStandardMaterial color="#ffffff" roughness={1.0} metalness={0.0} emissive="#ffffff" emissiveIntensity={0.6} toneMapped={false} />
                      </mesh>
                      <mesh position={photoPos}>
                          <planeGeometry args={photoArgs} />
                          <meshStandardMaterial ref={photoMatRef} map={texture} emissiveMap={texture} roughness={0.4} metalness={0.0} color="white" emissive="white" emissiveIntensity={0.25} toneMapped={false} />
                      </mesh>
                      {signatureTexture && (
                          <mesh position={textPos}>
                              <planeGeometry args={textArgs} />
                              <meshBasicMaterial map={signatureTexture} transparent={true} opacity={0.85} depthWrite={false} />
                          </mesh>
                      )}
                  </group>
              </group>
          );
      };

      const GiftBoxMesh = ({ item, mixFactor }) => {
          const groupRef = useRef(null);
          const currentMixRef = useRef(1);
          const vecPos = useMemo(() => new THREE.Vector3(), []);
          const vecScale = useMemo(() => new THREE.Vector3(), []);
          const { ribbonColor, ribbonMaterial } = useMemo(() => {
              const c = item.color;
              const luminance = 0.299 * c.r + 0.587 * c.g + 0.114 * c.b;
              let ribColorStr = "#FFD700"; 
              if (c.b > c.r + 0.2 && c.b > c.g + 0.2) { ribColorStr = "#E0E0E0"; } 
              else if (luminance > 0.6) { ribColorStr = "#AA0000"; }
              return {
                  ribbonColor: new THREE.Color(ribColorStr),
                  ribbonMaterial: new THREE.MeshStandardMaterial({
                      color: ribColorStr, roughness: 0.2, metalness: 0.8, emissive: ribColorStr, emissiveIntensity: 0.2
                  })
              }
          }, [item.color]);

          useFrame((state, delta) => {
              if (!groupRef.current) return;
              const speed = 2.0 * delta;
              currentMixRef.current = lerp(currentMixRef.current, mixFactor, speed);
              const t = currentMixRef.current;
              vecPos.lerpVectors(item.chaosPos, item.targetPos, t);
              groupRef.current.position.copy(vecPos);
              vecScale.lerpVectors(item.chaosScale, item.targetScale, t);
              groupRef.current.scale.copy(vecScale);
              groupRef.current.rotation.copy(item.rotation);
              if (t < 0.5) {
                   groupRef.current.rotation.x += delta * 0.5;
                   groupRef.current.rotation.y += delta * 0.5;
              }
          });

          return (
              <group ref={groupRef}>
                  <mesh castShadow receiveShadow>
                      <boxGeometry args={[1, 1, 1]} />
                      <meshStandardMaterial color={item.color} roughness={0.4} metalness={0.1} />
                  </mesh>
                  <mesh scale={[0.2, 1.01, 1.01]} material={ribbonMaterial}><boxGeometry args={[1, 1, 1]} /></mesh>
                  <mesh scale={[1.01, 1.01, 0.2]} material={ribbonMaterial}><boxGeometry args={[1, 1, 1]} /></mesh>
                  <mesh position={[0, 0.5, 0]} rotation={[0, Math.PI / 4, 0]} material={ribbonMaterial} scale={[0.35, 0.35, 0.35]}>
                       <torusKnotGeometry args={[0.6, 0.15, 64, 8, 2, 3]} />
                  </mesh>
              </group>
          );
      };

      const generateCardTexture = () => {
          const canvas = document.createElement('canvas');
          canvas.width = 256; canvas.height = 320;
          const ctx = canvas.getContext('2d');
          if (ctx) { ctx.fillStyle = '#000000'; ctx.fillRect(0,0, 256, 320); }
          return new THREE.CanvasTexture(canvas);
      }

      const UserPhotoOrnament = ({ item, mixFactor, url, signatureTexture }) => {
          const texture = useLoader(THREE.TextureLoader, url);
          return <PhotoFrameMesh item={item} mixFactor={mixFactor} texture={texture} signatureTexture={signatureTexture} />;
      };

      const SuspensePhotoOrnament = (props) => {
           return (
              <React.Suspense fallback={
                   <group position={props.item.targetPos}>
                      <mesh scale={props.item.targetScale}>
                          <boxGeometry args={[1, 1.2, 0.05]} />
                          <meshStandardMaterial color="#eee" />
                      </mesh>
                   </group>
              }>
                  <UserPhotoOrnament {...props} />
              </React.Suspense>
          )
      }

      const getTypeOffsetIndex = (type) => {
          switch(type) {
              case 'BALL': return 0; case 'BOX': return 1; case 'STAR': return 2;
              case 'CANDY': return 3; case 'CRYSTAL': return 4; case 'PHOTO': return 5;
              default: return 0;
          }
      }

      const Ornaments = ({ mixFactor, type, count, colors, scale = 1, userImages = [], signatureText }) => {
        const meshRef = useRef(null);
        const dummy = useMemo(() => new THREE.Object3D(), []);
        const currentMixRef = useRef(1);

        const candyTexture = useMemo(() => {
            if (type === 'CANDY') return generateCandyStripeTexture();
            return null;
        }, [type]);

        const signatureTexture = useMemo(() => {
            if (type === 'PHOTO' && signatureText) return generateSignatureTexture(signatureText);
            return null;
        }, [type, signatureText]);

        const geometry = useMemo(() => {
            switch(type) {
                case 'CANDY': return createCandyCaneGeometry();
                case 'CRYSTAL': return createOrnStarGeometry(6, 1.0, 0.3, 0.1); 
                case 'STAR': return createOrnStarGeometry(5, 1.0, 0.5, 0.2);
                case 'BALL': return new THREE.SphereGeometry(1, 16, 16);
                case 'BOX': default: return new THREE.BoxGeometry(1, 1, 1);
            }
        }, [type]);

        const data = useMemo(() => {
          const items = [];
          const goldenAngle = Math.PI * (3 - Math.sqrt(5)); 
          const treeHeight = 18; const treeRadiusBase = 7.5; const apexY = 9; 
          const typeIndex = getTypeOffsetIndex(type);
          const angleOffset = typeIndex * (Math.PI * 2 / 6); 

          for (let i = 0; i < count; i++) {
            const progress = Math.sqrt((i + 1) / count) * 0.9; 
            const r = progress * treeRadiusBase;
            const y = apexY - progress * treeHeight;
            const theta = i * goldenAngle + angleOffset;
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            const tPos = new THREE.Vector3(x, y, z);
            const pushOut = (type === 'STAR' || type === 'PHOTO') ? 1.15 : 1.08;
            tPos.multiplyScalar(pushOut);

            let cPos, chaosTilt = 0;
            if (type === 'PHOTO') {
                const chaosRadius = 18; const chaosHeightRange = 12;
                const chaosY = ((i / count) - 0.5) * chaosHeightRange;
                const chaosTheta = i * goldenAngle;
                cPos = new THREE.Vector3(chaosRadius * Math.cos(chaosTheta), chaosY, chaosRadius * Math.sin(chaosTheta));
                chaosTilt = ((i % 5) - 2) * 0.15; 
            } else {
                cPos = randomVector3(25);
            }

            const colorHex = colors ? colors[Math.floor(Math.random() * colors.length)] : '#ffffff';
            const baseScaleVec = new THREE.Vector3(1, 1, 1);
            const randScale = Math.random() * 0.4 + 0.8;
            if (type === 'CANDY') baseScaleVec.setScalar(0.7); 
            else if (type === 'CRYSTAL') baseScaleVec.setScalar(0.6); 
            else if (type === 'STAR') baseScaleVec.setScalar(0.7);
            else if (type === 'BOX') baseScaleVec.set(1.0 + Math.random() * 0.3, 0.7 + Math.random() * 0.4, 1.0 + Math.random() * 0.3);

            const targetScale = baseScaleVec.clone().multiplyScalar(scale * randScale);
            let chaosScale = targetScale.clone();
            if (type === 'PHOTO') {
                const photoScale = 3.5 + Math.random() * 1.5;
                chaosScale.multiplyScalar(photoScale);
            }

            items.push({
              chaosPos: cPos, targetPos: tPos,
              rotation: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
              color: new THREE.Color(colorHex),
              targetScale: targetScale, chaosScale: chaosScale, chaosTilt: chaosTilt
            });
          }
          return items;
        }, [count, type, colors, scale]);

        const fallbackTextures = useMemo(() => {
            if (type !== 'PHOTO') return [];
            return [generateCardTexture()];
        }, [type]);

        useLayoutEffect(() => {
           if (!meshRef.current || type === 'PHOTO' || type === 'BOX') return;
           data.forEach((item, i) => {
               const color = type === 'CANDY' ? new THREE.Color('#ffffff') : item.color;
               meshRef.current.setColorAt(i, color);
               dummy.position.copy(item.targetPos);
               dummy.scale.copy(item.targetScale);
               dummy.rotation.copy(item.rotation);
               dummy.updateMatrix();
               meshRef.current.setMatrixAt(i, dummy.matrix);
           });
           if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
           meshRef.current.instanceMatrix.needsUpdate = true;
        }, [data, type, dummy]);

        useFrame((state, delta) => {
          if (!meshRef.current || type === 'PHOTO' || type === 'BOX') return;
          const speed = 2.0 * delta;
          currentMixRef.current = lerp(currentMixRef.current, mixFactor, speed);
          const t = currentMixRef.current;
          const currentPos = new THREE.Vector3();
          const currentScale = new THREE.Vector3();

          data.forEach((item, i) => {
            currentPos.lerpVectors(item.chaosPos, item.targetPos, t);
            dummy.position.copy(currentPos);
            if (type === 'STAR' && t > 0.8) {
               dummy.lookAt(0, currentPos.y, 0); dummy.rotateZ(Math.PI / 2); 
            } else if (type === 'CRYSTAL' && t > 0.8) {
               dummy.lookAt(0, currentPos.y, 0); 
            } else {
               dummy.rotation.copy(item.rotation);
               if (t < 0.5) {
                   dummy.rotation.x += delta * 0.5; dummy.rotation.y += delta * 0.5;
               }
            }
            currentScale.lerpVectors(item.chaosScale, item.targetScale, t);
            dummy.scale.copy(currentScale); 
            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
          });
          meshRef.current.instanceMatrix.needsUpdate = true;
        });

        if (type === 'PHOTO') {
            return (
                <group>
                    {data.map((item, i) => {
                        let imgSrc = undefined;
                        if (userImages && userImages.length > 0) {
                            if (i < userImages.length) imgSrc = userImages[i];
                        } 
                        const fallback = fallbackTextures[i % fallbackTextures.length];
                        if (imgSrc) return <SuspensePhotoOrnament key={i} item={item} mixFactor={mixFactor} url={imgSrc} signatureTexture={signatureTexture} />;
                        else return <PhotoFrameMesh key={i} item={item} mixFactor={mixFactor} texture={fallback} signatureTexture={signatureTexture} />;
                    })}
                </group>
            )
        }
        if (type === 'BOX') {
            return (
                <group>
                    {data.map((item, i) => ( <GiftBoxMesh key={i} item={item} mixFactor={mixFactor} /> ))}
                </group>
            )
        }
        return (
          <instancedMesh ref={meshRef} args={[geometry, undefined, count]}>
            <meshStandardMaterial map={candyTexture} roughness={type === 'CANDY' ? 0.2 : 0.15} metalness={type === 'CRYSTAL' ? 0.9 : 0.5} emissive={type === 'CRYSTAL' ? "#112244" : "#000000"} emissiveIntensity={0.2} />
          </instancedMesh>
        );
      };

      // --- GestureController.tsx ---
      const GestureController = ({ onGesture, isGuiVisible }) => {
        const webcamRef = useRef(null);
        const [model, setModel] = useState(null);
        const [loading, setLoading] = useState(true);
        const [cameraError, setCameraError] = useState(false);
        const [debugState, setDebugState] = useState("-");
        const [loadingMessage, setLoadingMessage] = useState("Initializing AI...");
        const onGestureRef = useRef(onGesture);
        useEffect(() => { onGestureRef.current = onGesture; }, [onGesture]);
        const lastDetectionTime = useRef(0);
        const ratioHistory = useRef([]); 
        const posHistory = useRef([]); 
        const isCurrentlyOpen = useRef(false); 
        const missedFrames = useRef(0); 

        useEffect(() => {
          let isMounted = true;
          const loadModel = async () => {
            try {
              setLoadingMessage("Connecting GPU...");
              await tf.ready();
              if (isMounted) setLoadingMessage("Loading Model...");
              // Use default TFHub model via CDN to avoid local file CORS issues
              const net = await handpose.load(); 
              if (isMounted) { setModel(net); setLoading(false); }
            } catch (err) {
              console.error(err);
              if (isMounted) setLoadingMessage("Model Error");
            }
          };
          loadModel();
          return () => { isMounted = false; };
        }, []);

        const runDetection = useCallback(async () => {
          if (model && webcamRef.current && webcamRef.current.video && webcamRef.current.video.readyState === 4) {
            const now = Date.now();
            if (now - lastDetectionTime.current < 100) { requestAnimationFrame(runDetection); return; }
            lastDetectionTime.current = now;
            const video = webcamRef.current.video;
            if (video.videoWidth === 0 || video.videoHeight === 0) { requestAnimationFrame(runDetection); return; }

            try {
              const predictions = await model.estimateHands(video);
              if (predictions.length > 0) {
                missedFrames.current = 0;
                const hand = predictions[0];
                const landmarks = hand.landmarks;
                const wrist = landmarks[0];
                const rawX = -1 * ((wrist[0] / video.videoWidth) * 2 - 1); 
                const rawY = -1 * ((wrist[1] / video.videoHeight) * 2 - 1);
                
                posHistory.current.push({x: rawX, y: rawY});
                if (posHistory.current.length > 8) posHistory.current.shift(); 
                const avgPos = posHistory.current.reduce((acc, curr) => ({ x: acc.x + curr.x, y: acc.y + curr.y }), {x:0, y:0});
                const x = avgPos.x / posHistory.current.length;
                const y = avgPos.y / posHistory.current.length;

                const tips = [8, 12, 16, 20]; const bases = [5, 9, 13, 17];
                const getDist = (p1, p2) => Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
                let totalBaseDist = 0; let totalTipDist = 0;
                for(let i=0; i<4; i++) {
                    totalBaseDist += getDist(wrist, landmarks[bases[i]]);
                    totalTipDist += getDist(wrist, landmarks[tips[i]]);
                }
                const avgBaseDist = totalBaseDist / 4; const avgTipDist = totalTipDist / 4;
                const rawRatio = avgTipDist / (avgBaseDist || 1);
                ratioHistory.current.push(rawRatio);
                if (ratioHistory.current.length > 5) ratioHistory.current.shift();
                const smoothedRatio = ratioHistory.current.reduce((a,b) => a+b, 0) / ratioHistory.current.length;

                if (!isCurrentlyOpen.current && smoothedRatio > 1.6) isCurrentlyOpen.current = true;
                else if (isCurrentlyOpen.current && smoothedRatio < 1.2) isCurrentlyOpen.current = false;

                const isOpen = isCurrentlyOpen.current;
                setDebugState(isOpen ? `OPEN` : `CLOSED`);
                if (onGestureRef.current) onGestureRef.current({ isOpen, position: { x, y }, isDetected: true });
              } else {
                missedFrames.current++;
                if (missedFrames.current > 5) {
                    isCurrentlyOpen.current = false; ratioHistory.current = []; posHistory.current = []; 
                    setDebugState("NO HAND");
                    if (onGestureRef.current) onGestureRef.current({ isOpen: false, position: {x:0, y:0}, isDetected: false });
                }
              }
            } catch (err) {}
          }
          requestAnimationFrame(runDetection);
        }, [model]);

        useEffect(() => {
          if (model && !loading) {
            const timer = requestAnimationFrame(runDetection);
            return () => cancelAnimationFrame(timer);
          }
        }, [model, loading, runDetection]);

        const boxStyle = "w-28 h-36 md:w-48 md:h-36 rounded-lg border-[#d4af37]/50 bg-black/90 border overflow-hidden shadow-[0_0_20px_rgba(212,175,55,0.2)]";
        return (
          <div className={`fixed bottom-4 right-4 z-50 transition-all duration-500 ease-in-out ${isGuiVisible ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-10 pointer-events-none'}`}>
            <div className={`relative ${boxStyle}`}>
                {cameraError ? (
                   <div className="flex flex-col items-center justify-center h-full text-[#d4af37] p-2 text-center gap-2">
                      <span className="text-xl">ðŸ“·</span>
                      <span className="text-[10px] font-luxury uppercase tracking-widest">Camera Unavailable</span>
                   </div>
                ) : (
                  <>
                      {/* OPTIMIZATION: Forced low resolution for AI processing speed */}
                      <Webcam ref={webcamRef} mirrored={true} width={240} height={180} videoConstraints={{ facingMode: "user" }} className={`w-full h-full object-cover transition-opacity duration-500 ${loading ? 'opacity-20' : 'opacity-80'}`} onUserMediaError={() => setCameraError(true)} />
                      {!loading && <div className="absolute inset-0 bg-gradient-to-b from-transparent via-[#d4af37]/10 to-transparent animate-scan pointer-events-none" />}
                  </>
                )}
                {loading && !cameraError && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center text-[#d4af37] gap-2 p-4 bg-black/80 backdrop-blur-sm">
                        <div className="w-5 h-5 border-2 border-[#d4af37] border-t-transparent rounded-full animate-spin"></div>
                        <span className="text-[9px] font-luxury uppercase tracking-widest text-center animate-pulse">{loadingMessage}</span>
                    </div>
                )}
                <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/90 to-transparent pt-6 pb-2 px-3 flex flex-col md:flex-row justify-end md:justify-between items-start md:items-end gap-0 md:gap-0">
                  <span className="text-[9px] md:text-[8px] text-[#d4af37]/80 font-luxury tracking-widest uppercase mb-0.5 md:mb-0">Sensors</span>
                  <span className={`text-[11px] md:text-[9px] font-mono font-bold ${debugState.includes("OPEN") ? "text-white drop-shadow-[0_0_5px_rgba(255,255,255,0.8)]" : "text-[#d4af37]"}`}>{debugState}</span>
                </div>
            </div>
          </div>
        );
      };

      // --- Experience.tsx ---
      const BALL_COLORS = ['#8B0000', '#D32F2F', '#1B5E20', '#D4AF37', '#C0C0C0', '#191970']; 
      const BOX_COLORS = ['#800000', '#1B5E20', '#D4AF37', '#FFFFFF', '#4B0082', '#2F4F4F', '#008080', '#8B4513', '#DC143C'];
      const STAR_COLORS = ['#FFD700', '#FDB931']; 
      const CRYSTAL_COLORS = ['#F0F8FF', '#E0FFFF', '#B0E0E6']; 
      const CANDY_COLORS = ['#FFFFFF']; 

      const SceneController = ({ inputRef, groupRef }) => {
          const { camera, gl } = useThree();
          const vec = useMemo(() => new THREE.Vector3(), []);
          const zoomTarget = useRef(32); 
          const isDragging = useRef(false);
          const lastPointerX = useRef(0);
          const lastTouchDistance = useRef(null);
          const rotationVelocity = useRef(0.002); 
          const wasDetected = useRef(false); 
          
          const grabOffset = useRef(0); 
          const grabOffsetX = useRef(0); // For vertical tilt offset
          
          const currentInput = useRef({ x: 0, y: 0 }); 

          useEffect(() => {
              const canvas = gl.domElement;
              canvas.style.touchAction = 'none';
              const onWheel = (e) => { e.preventDefault(); zoomTarget.current += e.deltaY * 0.02; zoomTarget.current = THREE.MathUtils.clamp(zoomTarget.current, 12, 55); };
              const onPointerDown = (e) => { if (e.isPrimary && e.button === 0) { isDragging.current = true; lastPointerX.current = e.clientX; canvas.setPointerCapture(e.pointerId); rotationVelocity.current = 0; } };
              const onPointerUp = (e) => { if (e.isPrimary) { isDragging.current = false; canvas.releasePointerCapture(e.pointerId); } };
              const onPointerMove = (e) => { if (e.isPrimary && isDragging.current && groupRef.current && lastTouchDistance.current === null) { const deltaX = e.clientX - lastPointerX.current; lastPointerX.current = e.clientX; const rotationAmount = deltaX * 0.005; groupRef.current.rotation.y += rotationAmount; rotationVelocity.current = rotationAmount; } };
              const onTouchStart = (e) => { if (e.touches.length === 2) { const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; lastTouchDistance.current = Math.sqrt(dx * dx + dy * dy); } };
              const onTouchMove = (e) => { if (e.touches.length === 2) { if (e.cancelable) e.preventDefault(); const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; const distance = Math.sqrt(dx * dx + dy * dy); if (lastTouchDistance.current !== null) { const diff = lastTouchDistance.current - distance; zoomTarget.current += diff * 0.15; zoomTarget.current = THREE.MathUtils.clamp(zoomTarget.current, 12, 55); } lastTouchDistance.current = distance; } };
              const onTouchEnd = () => { lastTouchDistance.current = null; };

              canvas.addEventListener('wheel', onWheel, { passive: false });
              canvas.addEventListener('pointerdown', onPointerDown); canvas.addEventListener('pointerup', onPointerUp);
              canvas.addEventListener('pointermove', onPointerMove); canvas.addEventListener('pointerleave', onPointerUp);
              canvas.addEventListener('touchstart', onTouchStart, { passive: false }); canvas.addEventListener('touchmove', onTouchMove, { passive: false });
              canvas.addEventListener('touchend', onTouchEnd);
              return () => { canvas.removeEventListener('wheel', onWheel); canvas.removeEventListener('pointerdown', onPointerDown); canvas.removeEventListener('pointerup', onPointerUp); canvas.removeEventListener('pointermove', onPointerMove); canvas.removeEventListener('touchstart', onTouchStart); canvas.removeEventListener('touchmove', onTouchMove); canvas.removeEventListener('touchend', onTouchEnd); };
          }, [gl, groupRef]);

          useFrame((state, delta) => {
              const safeDelta = Math.min(delta, 0.1);
              const targetX = inputRef.current.x; const targetY = inputRef.current.y;
              const isHandDetected = !!inputRef.current.isDetected;
              const inputSmoothing = 4.0 * safeDelta;
              currentInput.current.x = THREE.MathUtils.lerp(currentInput.current.x, targetX, inputSmoothing);
              currentInput.current.y = THREE.MathUtils.lerp(currentInput.current.y, targetY, inputSmoothing);
              
              // Camera updates based on zoom
              const camX = currentInput.current.x * 4; 
              // We move camera Y slightly for parallax, but main vertical control is now Rotation X
              const camY = currentInput.current.y * 2; 
              const camZ = zoomTarget.current + Math.abs(currentInput.current.x) * 2; 
              camera.position.lerp(vec.set(camX, camY, camZ), 4.0 * safeDelta); 
              camera.lookAt(0, 0, 0);

              if (groupRef.current) {
                  if (isHandDetected) {
                      // Horizontal Rotation (Y-Axis)
                      const HAND_ROTATION_FACTOR_Y = Math.PI * 1.2; 
                      const targetHandRotationY = currentInput.current.x * HAND_ROTATION_FACTOR_Y;

                      // Vertical Rotation (X-Axis / Tilt) - New Feature
                      // FIXED: Inverted the direction by adding a negative sign. 
                      // Now hand UP (-1 y) -> Positive Rot X (Tilt towards) -> Actually we want Hand Up to look Up. 
                      // Let's stick to standard camera controls: Drag Down to look Up. 
                      // If Hand moves UP (y=-1), we want tree to tilt BACK (negative Rot X).
                      // targetHandRotationX = (-1) * factor = negative. 
                      // So removing the negative sign or keeping positive?
                      // Let's try inverting the input Y directly.
                      const HAND_ROTATION_FACTOR_X = Math.PI * 0.35; 
                      // INVERTED LOGIC HERE:
                      const targetHandRotationX = -currentInput.current.y * HAND_ROTATION_FACTOR_X; 

                      if (!wasDetected.current) { 
                          grabOffset.current = groupRef.current.rotation.y - targetHandRotationY; 
                          grabOffsetX.current = groupRef.current.rotation.x - targetHandRotationX;
                          rotationVelocity.current = 0; 
                      }
                      
                      const targetAngleY = targetHandRotationY + grabOffset.current;
                      const targetAngleX = targetHandRotationX + grabOffsetX.current;
                      
                      const smoothFactor = 6.0 * safeDelta;
                      
                      // Apply Y Rotation
                      const prevRotY = groupRef.current.rotation.y;
                      groupRef.current.rotation.y = THREE.MathUtils.lerp(prevRotY, targetAngleY, smoothFactor);
                      rotationVelocity.current = (groupRef.current.rotation.y - prevRotY);

                      // Apply X Rotation (Vertical Tilt)
                      const prevRotX = groupRef.current.rotation.x;
                      groupRef.current.rotation.x = THREE.MathUtils.lerp(prevRotX, targetAngleX, smoothFactor);

                      wasDetected.current = true;
                  } else {
                      if (wasDetected.current) { 
                          if (Math.abs(rotationVelocity.current) < 0.0001) { rotationVelocity.current = 0.002; } 
                          wasDetected.current = false; 
                      }
                      
                      if (!isDragging.current) {
                          // Continue spinning Y
                          groupRef.current.rotation.y += rotationVelocity.current;
                          const baseSpeed = 0.002;
                          rotationVelocity.current = THREE.MathUtils.lerp(rotationVelocity.current, baseSpeed, safeDelta * 0.5);
                          
                          // Smoothly return X rotation (tilt) to 0 when hand is lost
                          if(Math.abs(groupRef.current.rotation.x) > 0.001) {
                              groupRef.current.rotation.x = THREE.MathUtils.lerp(groupRef.current.rotation.x, 0, safeDelta * 2.0);
                          } else {
                              groupRef.current.rotation.x = 0;
                          }
                      }
                  }
              }
          });
          return null;
      };

      const SceneContent = ({ mixFactor, colors, inputRef, userImages, signatureText }) => {
        const groupRef = useRef(null);
        const photoCount = (userImages && userImages.length > 0) ? userImages.length : 10;
        return (
          <>
            <SceneController inputRef={inputRef} groupRef={groupRef} />
            <ambientLight intensity={0.4} />
            <spotLight position={[20, 20, 20]} angle={0.4} penumbra={1} intensity={2.0} color="#fff5d0" castShadow />
            <pointLight position={[-10, 5, -10]} intensity={1.2} color="#00ff00" />
            <pointLight position={[10, -5, 10]} intensity={1.2} color="#ff0000" />
            <pointLight position={[0, 10, 10]} intensity={0.5} color="#ffffff" />
            
            {/* Using Remote HDRI to bypass file:// CORS */}
            <Environment files='https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/potsdamer_platz_1k.hdr' background={false} />
            <Stars radius={100} depth={50} count={3000} factor={4} saturation={0} fade speed={1} />
            <Snow mixFactor={mixFactor} />

            <group ref={groupRef} position={[0, 0, 0]}>
              <TopStar mixFactor={mixFactor} />
              <Foliage mixFactor={mixFactor} colors={colors} />
              <SpiralLights mixFactor={mixFactor} />
              <Ornaments mixFactor={mixFactor} type="BALL" count={60} scale={0.5} colors={BALL_COLORS} />
              <Ornaments mixFactor={mixFactor} type="BOX" count={30} scale={0.6} colors={BOX_COLORS} />
              <Ornaments mixFactor={mixFactor} type="STAR" count={25} scale={0.5} colors={STAR_COLORS} />
              <Ornaments mixFactor={mixFactor} type="CRYSTAL" count={40} scale={0.4} colors={CRYSTAL_COLORS} />
              <Ornaments mixFactor={mixFactor} type="CANDY" count={40} scale={0.8} colors={CANDY_COLORS} />
              <Ornaments mixFactor={mixFactor} type="PHOTO" count={photoCount} userImages={userImages} signatureText={signatureText} />
            </group>

            <EffectComposer enableNormalPass={false} multisampling={0}>
              <Bloom luminanceThreshold={0.9} mipmapBlur intensity={1.2} radius={0.6} />
              <Vignette eskil={false} offset={0.1} darkness={1.1} />
            </EffectComposer>
          </>
        );
      };

      const Experience = (props) => {
        return (
          <Canvas dpr={[1, 1.25]} camera={{ position: [0, 0, 32], fov: 45, near: 5, far: 80 }} gl={{ antialias: false, toneMapping: THREE.ACESFilmicToneMapping, toneMappingExposure: 1.0 }} shadows style={{ touchAction: 'none' }}>
            <SceneContent {...props} />
          </Canvas>
        );
      };

      // --- 3. APP.tsx ---
      const App = () => {
        const [targetMix, setTargetMix] = useState(1); 
        const [colors] = useState({ bottom: '#022b1c', top: '#217a46' });
        const inputRef = useRef({ x: 0, y: 0, isDetected: false });
        const [userImages, setUserImages] = useState([]);
        const [isProcessing, setIsProcessing] = useState(false);
        const fileInputRef = useRef(null);
        const [isSignatureOpen, setIsSignatureOpen] = useState(false);
        const [signatureText, setSignatureText] = useState("");
        const [activePhotoUrl, setActivePhotoUrl] = useState(null);
        const [showCamera, setShowCamera] = useState(true);

        const handleGesture = useCallback((data) => {
          if (data.isDetected) {
              const newTarget = data.isOpen ? 0 : 1;
              setTargetMix(prev => { if (prev !== newTarget) return newTarget; return prev; });
              inputRef.current = { x: data.position.x * 1.2, y: data.position.y, isDetected: true };
          } else {
              inputRef.current.isDetected = false;
          }
        }, []);

        const toggleState = () => setTargetMix(prev => prev === 1 ? 0 : 1);
        const handleUploadClick = () => fileInputRef.current?.click();
        const handleSignatureClick = () => {
            if (userImages.length > 0) setActivePhotoUrl(userImages[Math.floor(Math.random() * userImages.length)]);
            else setActivePhotoUrl(null);
            setIsSignatureOpen(true);
        };

        const handleFileChange = (e) => {
            if (e.target.files && e.target.files.length > 0) {
                setIsProcessing(true);
                setTargetMix(0);
                setTimeout(() => {
                    const files = Array.from(e.target.files).slice(0, 30); 
                    const urls = files.map(file => URL.createObjectURL(file));
                    setUserImages(prev => { prev.forEach(url => URL.revokeObjectURL(url)); return urls; });
                    if (fileInputRef.current) fileInputRef.current.value = '';
                    setTimeout(() => { setIsProcessing(false); setTimeout(() => { setTargetMix(1); }, 800); }, 1200); 
                }, 50);
            }
        };

        const iconButtonClass = "group relative w-10 h-10 md:w-12 md:h-12 rounded-full bg-black/30 backdrop-blur-md border border-white/20 text-slate-300 transition-all duration-500 ease-out hover:border-white/60 hover:text-white hover:bg-white/10 hover:shadow-[0_0_25px_rgba(255,255,255,0.2)] active:scale-90 active:bg-white/20 flex justify-center items-center cursor-pointer";
        const textButtonClass = "group relative w-auto px-8 h-10 overflow-hidden rounded-sm bg-black/80 backdrop-blur-md border border-white/40 text-slate-300 font-luxury text-[11px] uppercase tracking-[0.25em] transition-all duration-500 ease-out hover:border-white/80 hover:text-black hover:bg-white hover:shadow-[0_0_25px_rgba(255,255,255,0.2)] active:scale-95 flex justify-center items-center cursor-pointer";

        return (
          <div className="relative w-full h-screen bg-black overflow-hidden">
            <input type="file" ref={fileInputRef} onChange={handleFileChange} accept="image/*" multiple className="hidden" />
            {isProcessing && (
                <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center bg-black/90 backdrop-blur-md transition-all duration-500 animate-in fade-in">
                    <div className="relative w-16 h-16 mb-6">
                        <div className="absolute inset-0 border-2 border-t-[#d4af37] border-r-transparent border-b-[#d4af37] border-l-transparent rounded-full animate-spin"></div>
                        <div className="absolute inset-2 border-2 border-t-transparent border-r-white/30 border-b-transparent border-l-white/30 rounded-full animate-spin-reverse"></div>
                        <div className="absolute inset-0 flex items-center justify-center text-[#d4af37] text-xl animate-pulse">âœ¦</div>
                    </div>
                    <div className="text-[#d4af37] font-luxury tracking-[0.25em] text-xs uppercase animate-pulse">åœ£è¯žæ ‘è£…é¥°ä¸­...</div>
                </div>
            )}
            <div className={`absolute top-[5%] left-0 w-full flex justify-center pointer-events-none z-0 transition-opacity duration-700 ${isSignatureOpen ? 'opacity-0' : 'opacity-100'}`}>
              <h1 className="font-script text-6xl md:text-9xl text-center leading-[1.5] py-10" style={{ background: 'linear-gradient(to bottom, #ffffff 20%, #e8e8e8 50%, #b0b0b0 90%)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', filter: 'drop-shadow(0px 5px 5px rgba(0,0,0,0.8)) drop-shadow(0px 0px 20px rgba(255,255,255,0.4))' }}>Merry Christmas</h1>
            </div>
            <div className={`absolute inset-0 z-10 transition-all duration-700 ${isSignatureOpen ? 'blur-sm scale-95 opacity-50' : 'blur-0 scale-100 opacity-100'}`}>
              <Experience mixFactor={targetMix} colors={colors} inputRef={inputRef} userImages={userImages} signatureText={signatureText} />
            </div>
            {isSignatureOpen && (
                <div className="absolute inset-0 z-40 flex items-center justify-center p-4 bg-black/60 backdrop-blur-md transition-opacity duration-500 animate-in fade-in">
                    <div className="relative bg-[#f8f8f8] p-4 pb-12 shadow-[0_0_50px_rgba(255,255,255,0.2)] transform transition-transform duration-700 scale-100 rotate-[-2deg]" style={{ width: 'min(80vw, 320px)', aspectRatio: '3.5/4.2' }}>
                        <button onClick={() => setIsSignatureOpen(false)} className="absolute -top-4 -right-4 w-8 h-8 rounded-full bg-black border border-white/20 text-white flex items-center justify-center hover:bg-white hover:text-black transition-colors z-50">Ã—</button>
                        <div className="w-full h-[75%] bg-[#1a1a1a] overflow-hidden relative shadow-inner">
                            {activePhotoUrl ? ( <img src={activePhotoUrl} alt="Memory" className="w-full h-full object-cover" /> ) : ( <div className="w-full h-full flex items-center justify-center text-white/40 font-body text-lg italic tracking-widest text-center px-4">æˆ‘~ä¸€ç›´éƒ½æƒ³å¯¹ä½ è¯´~</div> )}
                            <div className="absolute inset-0 bg-gradient-to-tr from-white/0 via-white/5 to-white/20 pointer-events-none" />
                        </div>
                        <div className="absolute bottom-0 left-0 w-full h-[25%] flex items-center justify-center px-4">
                            <input autoFocus type="text" placeholder="Sign here..." value={signatureText} onChange={(e) => setSignatureText(e.target.value)} className="w-full text-center bg-transparent border-none outline-none font-script text-3xl md:text-4xl text-[#1a1a1a] placeholder:text-gray-300/50" style={{ transform: 'translateY(-5px) rotate(-1deg)' }} maxLength={20} />
                        </div>
                    </div>
                    <div className="absolute bottom-10 left-0 w-full flex justify-center">
                        <button onClick={() => setIsSignatureOpen(false)} className={textButtonClass}>å®Œæˆç­¾å</button>
                    </div>
                </div>
            )}
            <div className={`absolute top-6 right-6 md:top-10 md:right-10 z-30 pointer-events-auto flex flex-row md:flex-col items-center md:items-end gap-3 md:gap-4 transition-opacity duration-500 ${isSignatureOpen || isProcessing ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}>
                <button onClick={() => setShowCamera(prev => !prev)} className={`${iconButtonClass} ${showCamera ? 'text-white border-white/60 bg-white/10' : 'text-slate-300'}`} title={showCamera ? "éšè—æ‘„åƒå¤´" : "æ˜¾ç¤ºæ‘„åƒå¤´"}>
                    {showCamera ? ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.2} stroke="currentColor" className="w-5 h-5 md:w-6 md:h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" /></svg> ) : ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.2} stroke="currentColor" className="w-5 h-5 md:w-6 md:h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M12 18.75H4.5a2.25 2.25 0 01-2.25-2.25V9m12.841 9.091L16.5 19.5m-1.409-1.409c.407-.407.659-.97.659-1.591v-9a2.25 2.25 0 00-2.25-2.25h-9c-.621 0-1.184.252-1.591.659m3.75-3.75l3.75-3.75" /><path strokeLinecap="round" strokeLinejoin="round" d="M3 3l18 18" /></svg> )}
                </button>
                <button onClick={handleUploadClick} className={iconButtonClass} title="ä¸Šä¼ ç…§ç‰‡"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.2} stroke="currentColor" className="w-5 h-5 md:w-6 md:h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" /></svg></button>
                <button onClick={handleSignatureClick} className={iconButtonClass} title="æ‹ç«‹å¾—ç­¾å"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.2} stroke="currentColor" className="w-5 h-5 md:w-6 md:h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></svg></button>
                <button onClick={toggleState} className={iconButtonClass} title={targetMix === 1 ? "æ•£å¼€" : "èšæ‹¢"}>
                  {targetMix === 1 ? ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.2} stroke="currentColor" className="w-5 h-5 md:w-6 md:h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" /></svg> ) : ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.2} stroke="currentColor" className="w-5 h-5 md:w-6 md:h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25" /></svg> )}
                </button>
            </div>
            <div className={`absolute bottom-6 left-6 z-20 pointer-events-none transition-opacity duration-500 ${isSignatureOpen ? 'opacity-0' : 'opacity-100'}`}>
                  <div className="text-white/20 text-[10px] uppercase tracking-widest font-luxury">
                      <div>é€ç»™ç”œç”œçš„åœ£è¯žç¤¼ç‰©</div>
                      <div className="text-slate-500">Made By Dong.Y</div>
                  </div>
            </div>
            <GestureController onGesture={handleGesture} isGuiVisible={showCamera} />
          </div>
        );
      };

      // --- MOUNT ---
      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(<App />);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
